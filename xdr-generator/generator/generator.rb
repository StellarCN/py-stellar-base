# Note:
# 1. Python reserved words in identifiers are automatically suffixed with "_".
# 2. You can generate the file with the following command
#   xdrgen -o OUTPUT_DIR INPUT -l python
# 3. The generated code is unformatted, I suggest you format it by the following command:
#   autoflake --in-place --ignore-init-module-imports --remove-all-unused-imports OUTPUT_DIR/*.py
#   isort OUTPUT_DIR/
#   black OUTPUT_DIR/

AST = Xdrgen::AST

class Generator < Xdrgen::Generators::Base
  MAX_SIZE = (2 ** 32) - 1
  CIRCLE_IMPORT_UNION = %w[SCVal SCSpecTypeDef].freeze
  PYTHON_RESERVED_WORDS = %w[
    False None True and as assert async await break class continue def del
    elif else except finally for from global if import in is lambda match
    nonlocal not or pass raise return try while with yield case
  ].freeze

  def generate
    initialize_output_files
    render_base_classes
    render_definitions(@top)
  end

  private

  def initialize_output_files
    @constants_out = @output.open("constants.py")
    @constants_out.puts <<-EOS.strip_heredoc
      # This is an automatically generated file.
      # DO NOT EDIT or your changes may be overwritten
    EOS

    @init_out = @output.open("__init__.py")
    @init_out.puts <<-EOS.strip_heredoc
      # Automatically generated by xdrgen
      # DO NOT EDIT or your changes may be overwritten
      from .base import *
      from .constants import *
    EOS
  end

  def register_init_import(type_name)
    @init_out.puts "from .#{python_module_name(type_name)} import *"
  end

  def open_definition_file(definition_name)
    register_init_import(definition_name)
    @imported_types = Set.new
    out = @output.open("#{python_module_name(definition_name)}.py")
    render_common_import(out)
    out
  end

  def render_definitions(node)
    node.definitions.each { |defn| render_definition(defn) }
    node.namespaces.each { |namespace| render_definitions(namespace) }
  end

  def render_nested_definitions(defn)
    return unless defn.respond_to?(:nested_definitions)

    defn.nested_definitions.each { |nested| render_definition(nested) }
  end

  def render_definition(defn)
    render_nested_definitions(defn)

    case defn
    when AST::Definitions::Struct
      render_struct(defn)
    when AST::Definitions::Enum
      render_enum(defn)
    when AST::Definitions::Union
      render_import_in_func = CIRCLE_IMPORT_UNION.include?(defn.name)
      render_union(defn, render_import_in_func)
    when AST::Definitions::Typedef
      render_typedef(defn)
    when AST::Definitions::Const
      render_const(defn)
    end
  end

  def render_const(const)
    render_const_source_comment(@constants_out, const)
    @constants_out.puts "#{safe_identifier(const.name)}: int = #{const_value(const.value)}"
  end

  def render_enum(enum)
    enum_name = name(enum)
    out = open_definition_file(enum_name)

    out.puts "__all__ = ['#{enum_name}']"
    out.puts "class #{enum_name}(IntEnum):"
    out.indent(2) do
      render_source_comment(out, enum)
      enum.members.each do |member|
        out.puts "#{safe_identifier(member.name)} = #{member.value}"
      end

      out.puts <<~HEREDOC
        def pack(self, packer: Packer) -> None:
            packer.pack_int(self.value)

        @classmethod
        def unpack(cls, unpacker: Unpacker) -> #{enum_name}:
            value = unpacker.unpack_int()
            return cls(value)
      HEREDOC

      render_xdr_utils(out, enum_name)
    end

    out.close
  end

  def render_typedef(typedef)
    typedef_name = safe_identifier(typedef.name.camelize)
    typedef_name_underscore = safe_identifier(typedef.name.underscore)

    out = open_definition_file(typedef_name)
    render_import(out, typedef, typedef_name)

    out.puts "__all__ = ['#{typedef_name}']"

    out.puts "class #{typedef_name}:"
    out.indent(2) do
      render_source_comment(out, typedef)
      out.puts "def __init__(self, #{typedef_name_underscore}: #{type_hint_string(typedef, typedef_name)}) -> None:"
      out.indent(2) do
        render_array_length_checker(typedef, out)
        out.puts "self.#{typedef_name_underscore} = #{typedef_name_underscore}"
      end

      out.puts "def pack(self, packer: Packer) -> None:"
      out.indent(2) do
        encode_member(typedef, out)
      end

      out.puts "@classmethod"
      out.puts "def unpack(cls, unpacker: Unpacker) -> #{typedef_name}:"
      out.indent(2) do
        decode_member(typedef, out)
        out.puts "return cls(#{typedef_name_underscore})"
      end

      render_xdr_utils(out, typedef_name)
      out.puts <<~HEREDOC
        def __hash__(self):
            return hash(self.#{typedef_name_underscore})
        def __eq__(self, other: object):
            if not isinstance(other, self.__class__):
                return NotImplemented
            return self.#{typedef_name_underscore} == other.#{typedef_name_underscore}

        def __repr__(self):
            return f"<#{typedef_name} [#{typedef_name_underscore}={self.#{typedef_name_underscore}}]>"
      HEREDOC
    end

    out.close
  end

  def render_import(out, member, container_name)
    member_type = type_string(member.type)
    return if is_base_type(member.type) || container_name == member_type
    return if @imported_types.include?(member_type)

    @imported_types.add(member_type)
    out.puts "from .#{python_module_name(member_type)} import #{member_type}"
  end

  def non_void_arms(union)
    union.arms.reject(&:void?)
  end

  def render_union_arm_imports(out, union, union_name, render_import_in_func)
    if render_import_in_func
      out.puts "if TYPE_CHECKING:"
      out.indent(2) do
        non_void_arms(union).each do |arm|
          # This may cause duplicate imports, we can remove it with autoflake
          render_import(out, arm.declaration, union_name)
        end
      end
      return
    end

    non_void_arms(union).each do |arm|
      render_import(out, arm.declaration, union_name)
    end
  end

  def render_union_initializer(out, union, union_name, discriminant_name)
    out.puts <<~HEREDOC
      def __init__(
          self,
          #{discriminant_name}: #{type_hint_string(union.discriminant, union_name)},
    HEREDOC

    out.indent(2) do
      non_void_arms(union).each do |arm|
        arm_name = safe_identifier(arm.name.underscore)
        out.puts "#{arm_name}: Optional[#{type_hint_string(arm.declaration, union_name)}] = None,"
      end
    end

    out.puts ") -> None:"
    out.indent(2) do
      non_void_arms(union).each do |arm|
        render_array_length_checker(arm, out)
      end

      out.puts "self.#{discriminant_name} = #{discriminant_name}"
      non_void_arms(union).each do |arm|
        arm_name = safe_identifier(arm.name.underscore)
        out.puts "self.#{arm_name} = #{arm_name}"
      end
    end
  end

  def render_union_case_condition(discriminant_type, discriminant_name, union_case)
    if union_case.value.is_a?(AST::Identifier)
      case_name = safe_identifier(union_case.value.name)
      return "if #{discriminant_name} == #{type_string(discriminant_type)}.#{case_name}:"
    end

    if type_string(discriminant_type) == "Uint32"
      return "if #{discriminant_name}.uint32 == #{union_case.value.value}:"
    end

    "if #{discriminant_name} == #{union_case.value.value}:"
  end

  def render_union_pack(out, union, discriminant_name)
    out.puts "def pack(self, packer: Packer) -> None:"
    out.indent(2) do
      out.puts encode_type(union.discriminant, "self.#{discriminant_name}")

      union.normal_arms.each do |arm|
        arm.cases.each do |union_case|
          condition = render_union_case_condition(union.discriminant.type, "self.#{discriminant_name}", union_case)
          out.puts condition

          out.indent(2) do
            encode_member(arm, out, true) unless arm.void?
            out.puts "return"
          end
        end
      end

      if union.default_arm.present? && !union.default_arm.void?
        encode_member(union.default_arm, out, true)
      end
    end
  end

  def render_union_unpack_match(out, arm, union_name, discriminant_name, render_import_in_func)
    if arm.void?
      out.puts "return cls(#{discriminant_name}=#{discriminant_name})"
      return
    end

    render_import(out, arm.declaration, union_name) if render_import_in_func

    decode_member(arm, out)
    arm_name = safe_identifier(arm.name.underscore)
    out.puts "return cls(#{discriminant_name}=#{discriminant_name}, #{arm_name}=#{arm_name})"
  end

  def render_union_default_unpack(out, union, discriminant_name)
    if union.default_arm.present? && !union.default_arm.void?
      decode_member(union.default_arm, out)
      arm_name = safe_identifier(union.default_arm.name.underscore)
      out.puts "return cls(#{discriminant_name}=#{discriminant_name}, #{arm_name}=#{arm_name})"
      return
    end

    out.puts "return cls(#{discriminant_name}=#{discriminant_name})"
  end

  def render_union_unpack(out, union, union_name, discriminant_name, render_import_in_func)
    out.puts "@classmethod"
    out.puts "def unpack(cls, unpacker: Unpacker) -> #{union_name}:"
    out.indent(2) do
      out.puts "#{discriminant_name} = #{decode_type(union.discriminant)}"

      union.normal_arms.each do |arm|
        arm.cases.each do |union_case|
          condition = render_union_case_condition(union.discriminant.type, discriminant_name, union_case)
          out.puts condition

          out.indent(2) do
            render_union_unpack_match(out, arm, union_name, discriminant_name, render_import_in_func)
          end
        end
      end

      render_union_default_unpack(out, union, discriminant_name)
    end
  end

  def render_hash_and_eq(out, attribute_names)
    out.puts <<~HEREDOC
      def __hash__(self):
          return hash((#{attribute_names.map { |name| "self.#{name}" }.join(", ")},))
      def __eq__(self, other: object):
          if not isinstance(other, self.__class__):
              return NotImplemented
          return #{attribute_names.map { |name| "self.#{name} == other.#{name}" }.join(" and ")}
    HEREDOC
  end

  def render_union_repr(out, union, union_name, discriminant_name)
    out.puts "def __repr__(self):"
    out.indent(2) do
      out.puts "out = []"
      out.puts "out.append(f'#{discriminant_name}={self.#{discriminant_name}}')"
      non_void_arms(union).each do |arm|
        arm_name = safe_identifier(arm.name.underscore)
        out.puts "if self.#{arm_name} is not None:"
        out.indent(2) do
          out.puts "out.append(f'#{arm_name}={self.#{arm_name}}')"
        end
      end
      out.puts "return f\"<#{union_name} [{', '.join(out)}]>\""
    end
  end

  def render_union(union, render_import_in_func = false)
    union_name = name(union)
    out = open_definition_file(union_name)

    render_import(out, union.discriminant, union_name)
    render_union_arm_imports(out, union, union_name, render_import_in_func)

    out.puts "__all__ = ['#{union_name}']"
    out.puts "class #{union_name}:"
    out.indent(2) do
      render_source_comment(out, union)
      discriminant_name = safe_identifier(union.discriminant.name.underscore)
      render_union_initializer(out, union, union_name, discriminant_name)
      render_union_pack(out, union, discriminant_name)
      render_union_unpack(out, union, union_name, discriminant_name, render_import_in_func)

      render_xdr_utils(out, union_name)

      attribute_names = [discriminant_name] + non_void_arms(union).map { |arm| safe_identifier(arm.name.underscore) }
      render_hash_and_eq(out, attribute_names)
      render_union_repr(out, union, union_name, discriminant_name)
    end

    out.close
  end

  def struct_member_names(struct)
    struct.members.map { |member| safe_identifier(member.name.underscore) }
  end

  def render_struct_initializer(out, struct, struct_name)
    out.puts <<~HEREDOC
      def __init__(
          self,
    HEREDOC

    out.indent(2) do
      struct.members.each do |member|
        member_name = safe_identifier(member.name.underscore)
        out.puts "#{member_name}: #{type_hint_string(member.declaration, struct_name)},"
      end
    end

    out.puts ") -> None:"
    out.indent(2) do
      struct.members.each do |member|
        render_array_length_checker(member, out)
      end
      struct.members.each do |member|
        member_name = safe_identifier(member.name.underscore)
        out.puts "self.#{member_name} = #{member_name}"
      end
    end
  end

  def render_struct_pack(out, struct)
    out.puts "def pack(self, packer: Packer) -> None:"
    out.indent(2) do
      struct.members.each do |member|
        encode_member(member, out)
      end
    end
  end

  def render_struct_unpack(out, struct, struct_name)
    out.puts "@classmethod"
    out.puts "def unpack(cls, unpacker: Unpacker) -> #{struct_name}:"
    out.indent(2) do
      struct.members.each do |member|
        decode_member(member, out)
      end

      out.puts "return cls("
      out.indent(2) do
        struct.members.each do |member|
          member_name = safe_identifier(member.name.underscore)
          out.puts "#{member_name}=#{member_name},"
        end
      end
      out.puts ")"
    end
  end

  def render_struct_repr(out, struct_name, member_names)
    out.puts "def __repr__(self):"
    out.indent(2) do
      out.puts "out = ["
      out.indent(2) do
        member_names.each do |member_name|
          out.puts "f'#{member_name}={self.#{member_name}}',"
        end
      end
      out.puts "]"
      out.puts "return f\"<#{struct_name} [{', '.join(out)}]>\""
    end
  end

  def render_struct(struct)
    struct_name = name(struct)
    out = open_definition_file(struct_name)

    struct.members.each do |member|
      render_import(out, member.declaration, struct_name)
    end

    out.puts "__all__ = ['#{struct_name}']"

    out.puts "class #{struct_name}:"
    out.indent(2) do
      render_source_comment(out, struct)
      render_struct_initializer(out, struct, struct_name)
      render_struct_pack(out, struct)
      render_struct_unpack(out, struct, struct_name)

      render_xdr_utils(out, struct_name)

      member_names = struct_member_names(struct)
      render_hash_and_eq(out, member_names)
      render_struct_repr(out, struct_name, member_names)
    end

    out.close
  end

  def encode_member(member, out, is_union_member = false)
    member_name_underscore = safe_identifier(member.name.underscore)
    optional_member = member.type.sub_type == :optional

    if optional_member
      out.puts <<~HEREDOC
        if self.#{member_name_underscore} is None:
            packer.pack_uint(0)
        else:
            packer.pack_uint(1)
      HEREDOC
    end

    out.indent(optional_member ? 2 : 0) do
      if is_union_member
        # All members of union are actually optional.
        out.puts <<~HEREDOC
          if self.#{member_name_underscore} is None:
              raise ValueError("#{member_name_underscore} should not be None.")
        HEREDOC
      end

      case member.declaration
      when AST::Declarations::Array
        out.puts "packer.pack_uint(len(self.#{member_name_underscore}))" unless member.declaration.fixed?
        out.puts <<~HEREDOC
          for #{member_name_underscore}_item in self.#{member_name_underscore}:
              #{encode_type(member.declaration, "#{member_name_underscore}_item")}
        HEREDOC
      else
        out.puts encode_type(member.declaration, "self.#{member_name_underscore}")
      end
    end
  end

  def decode_member(member, out)
    member_name_underscore = safe_identifier(member.name.underscore)
    decoded_member_declaration = decode_type(member.declaration)

    case member.declaration
    when AST::Declarations::Array
      if member.declaration.fixed?
        _, size = member.declaration.type.array_size
        out.puts "length = #{size}"
      else
        out.puts "length = unpacker.unpack_uint()"
      end
      out.puts <<-EOS.strip_heredoc
        #{member_name_underscore} = []
        for _ in range(length):
            #{member_name_underscore}.append(#{decoded_member_declaration})
      EOS
    else
      if member.type.sub_type == :optional
        out.puts "#{member_name_underscore} = #{decoded_member_declaration} if unpacker.unpack_uint() else None"
      else
        out.puts "#{member_name_underscore} = #{decoded_member_declaration}"
      end
    end
  end

  def render_common_import(out)
    out.puts <<-EOS.strip_heredoc
      # This is an automatically generated file.
      # DO NOT EDIT or your changes may be overwritten
      from __future__ import annotations

      import base64
      from enum import IntEnum
      from typing import List, Optional, TYPE_CHECKING
      from xdrlib3 import Packer, Unpacker
      from .base import Integer, UnsignedInteger, Float, Double, Hyper, UnsignedHyper, Boolean, String, Opaque
      from .constants import *
    EOS
    out.break
  end

  def render_array_length_checker(member, out)
    case member.declaration
    when AST::Declarations::Array
      _, size = member.declaration.type.array_size
      member_name_underscore = safe_identifier(member.name.underscore)
      if member.declaration.fixed?
        out.puts <<~HEREDOC
          _expect_length = #{size}
          if #{member_name_underscore} and len(#{member_name_underscore}) != _expect_length:
              raise ValueError(f\"The length of `#{member_name_underscore}` should be {_expect_length}, but got {len(#{member_name_underscore})}.\")
        HEREDOC
      else
        out.puts <<~HEREDOC
          _expect_max_length = #{size || MAX_SIZE}
          if #{member_name_underscore} and len(#{member_name_underscore}) > _expect_max_length:
              raise ValueError(f\"The maximum length of `#{member_name_underscore}` should be {_expect_max_length}, but got {len(#{member_name_underscore})}.\")
        HEREDOC
      end
    end
  end

  def render_xdr_utils(out, name)
    out.puts <<~HEREDOC
      def to_xdr_bytes(self) -> bytes:
          packer = Packer()
          self.pack(packer)
          return packer.get_buffer()

      @classmethod
      def from_xdr_bytes(cls, xdr: bytes) -> #{name}:
          unpacker = Unpacker(xdr)
          return cls.unpack(unpacker)

      def to_xdr(self) -> str:
          xdr_bytes = self.to_xdr_bytes()
          return base64.b64encode(xdr_bytes).decode()

      @classmethod
      def from_xdr(cls, xdr: str) -> #{name}:
          xdr_bytes = base64.b64decode(xdr.encode())
          return cls.from_xdr_bytes(xdr_bytes)
    HEREDOC
  end

  def render_base_classes
    out = @output.open("base.py")
    base_py_content = IO.read("#{__dir__}/templates/base.py")
    out.puts(base_py_content)
    out.close
  end

  def encode_type(decl, value)
    case decl.type
    when AST::Typespecs::Int
      "Integer(#{value}).pack(packer)"
    when AST::Typespecs::UnsignedInt
      "UnsignedInteger(#{value}).pack(packer)"
    when AST::Typespecs::Hyper
      "Hyper(#{value}).pack(packer)"
    when AST::Typespecs::UnsignedHyper
      "UnsignedHyper(#{value}).pack(packer)"
    when AST::Typespecs::Float
      "Float(#{value}).pack(packer)"
    when AST::Typespecs::Double
      "Double(#{value}).pack(packer)"
    when AST::Typespecs::Quadruple
      raise "cannot render quadruple in Python"
    when AST::Typespecs::Bool
      "Boolean(#{value}).pack(packer)"
    when AST::Typespecs::Opaque
      "Opaque(#{value}, #{decl.size || MAX_SIZE}, #{decl.fixed? ? "True" : "False"}).pack(packer)"
    when AST::Typespecs::String
      "String(#{value}, #{decl.size || MAX_SIZE}).pack(packer)"
    else
      "#{value}.pack(packer)"
    end
  end

  def decode_type(decl)
    case decl.type
    when AST::Typespecs::Int
      "Integer.unpack(unpacker)"
    when AST::Typespecs::UnsignedInt
      "UnsignedInteger.unpack(unpacker)"
    when AST::Typespecs::Hyper
      "Hyper.unpack(unpacker)"
    when AST::Typespecs::UnsignedHyper
      "UnsignedHyper.unpack(unpacker)"
    when AST::Typespecs::Float
      "Float.unpack(unpacker)"
    when AST::Typespecs::Double
      "Double.unpack(unpacker)"
    when AST::Typespecs::Quadruple
      raise "cannot render quadruple in Python"
    when AST::Typespecs::Bool
      "Boolean.unpack(unpacker)"
    when AST::Typespecs::Opaque
      "Opaque.unpack(unpacker, #{decl.size || MAX_SIZE}, #{decl.fixed? ? "True" : "False"})"
    when AST::Typespecs::String
      "String.unpack(unpacker)"
    when AST::Typespecs::Simple
      "#{name(decl.type.resolved_type)}.unpack(unpacker)"
    when AST::Concerns::NestedDefinition
      "#{name(decl.type)}.unpack(unpacker)"
    else
      raise "Unknown typespec: #{decl.type.class.name}"
    end
  end

  def render_source_comment(out, defn)
    return if defn.is_a?(AST::Definitions::Namespace)

    out.puts <<-EOS.strip_heredoc
      """
      XDR Source Code::

    EOS
    out.indent(2) do
      out.puts defn.text_value
    end

    out.puts '"""'
  end

  def render_const_source_comment(out, defn)
    return if defn.is_a?(AST::Definitions::Namespace)

    out.puts "#: #{defn.text_value}"
  end

  def type_hint_string(decl, container_name)
    type_hint = type_string(decl.type)
    type_hint = "\"#{type_hint}\"" if type_hint == container_name

    case decl.type.sub_type
    when :optional
      "Optional[#{type_hint}]"
    when :var_array, :array
      "List[#{type_hint}]"
    else
      type_hint
    end
  end

  def is_base_type(type)
    case type
    when AST::Typespecs::Bool,
      AST::Typespecs::Double,
      AST::Typespecs::Float,
      AST::Typespecs::Hyper,
      AST::Typespecs::Int,
      AST::Typespecs::Opaque,
      AST::Typespecs::String,
      AST::Typespecs::UnsignedHyper,
      AST::Typespecs::UnsignedInt
      true
    else
      false
    end
  end

  def type_string(type)
    case type
    when AST::Typespecs::Bool
      "bool"
    when AST::Typespecs::Double
      "float"
    when AST::Typespecs::Float
      "float"
    when AST::Typespecs::Hyper
      "int"
    when AST::Typespecs::Int
      "int"
    when AST::Typespecs::Opaque
      "bytes"
    when AST::Typespecs::Quadruple
      raise "no quadruple support for Python"
    when AST::Typespecs::String
      "bytes"
    when AST::Typespecs::UnsignedHyper
      "int"
    when AST::Typespecs::UnsignedInt
      "int"
    when AST::Typespecs::Simple
      name(type)
    when AST::Definitions::Base
      name(type)
    when AST::Concerns::NestedDefinition
      name(type)
    else
      raise "Unknown reference type: #{type.class.name}, #{type.class.ancestors}"
    end
  end

  def name(named)
    parent = name(named.parent_defn) if named.is_a?(AST::Concerns::NestedDefinition)
    result = safe_identifier(named.name.camelize)
    "#{parent}#{result}"
  end

  def safe_identifier(identifier)
    identifier = identifier.to_s
    return "#{identifier}_" if PYTHON_RESERVED_WORDS.include?(identifier)

    identifier
  end

  def python_module_name(type_name)
    safe_identifier(type_name.to_s.underscore)
  end

  def const_value(value)
    if value.is_a?(String) && value.match?(/\A[A-Za-z_][A-Za-z0-9_]*\z/)
      return safe_identifier(value)
    end

    return safe_identifier(value.name) if value.is_a?(AST::Identifier)

    value
  end
end
